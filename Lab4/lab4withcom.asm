assume CS:code, DS:data

; Макрос для сохранения переменной X (размером в двойное слово) в стек
PUSHM macro X
    push word ptr X+2    ; Сначала сохраняем старшие 2 байта переменной X
    push word ptr X      ; Затем сохраняем младшие 2 байта переменной X
endm

; Макрос для извлечения переменной X (размером в двойное слово) из стека
POPM macro X
    pop word ptr X       ; Сначала извлекаем младшие 2 байта переменной X
    pop word ptr X+2     ; Затем извлекаем старшие 2 байта переменной X
endm

; Макрос для вызова процедуры по имени P
CALLM macro P
    LOCAL after_callm    ; Локальная метка, чтобы вернуться после вызова процедуры
    push offset after_callm  ; Сохраняем адрес возврата в стек
    jmp P                ; Переходим к процедуре P
    after_callm:         ; Метка для возврата из процедуры
endm

; Макрос для возврата из процедуры с удалением N байт из стека
RETM macro N
    pop AX               ; Извлекаем адрес возврата из стека
    add SP, N            ; Освобождаем N байт из стека (для параметров процедуры)
    jmp AX               ; Переходим по извлечённому адресу возврата
endm

; Макрос для цикла, аналог команды LOOP
LOOPM macro L
    dec CX               ; Уменьшаем регистр CX на 1
    jnz L                ; Переход на метку L, если CX не равен 0
endm

; Сегмент данных
data segment
    msg    db "Hello, world!$"   ; Сообщение для вывода на экран
    var    dw 5678h              ; Переменная var (младшее слово)
           dw 1234h              ; Переменная var (старшее слово)
    count  dw 5                 ; Счётчик для цикла
data ends

; Сегмент кода
code segment
start:
    ; Инициализация сегмента данных
    mov AX, data          ; Загружаем адрес сегмента данных в AX
    mov DS, AX            ; Устанавливаем DS для доступа к данным

    ; Выводим строку "Hello, world!" на экран
    mov AH, 09h           ; Функция DOS для вывода строки
    mov DX, offset msg    ; Загружаем адрес строки в DX
    int 21h               ; Вызов прерывания DOS

    ; Сохраняем двойное слово var в стек
    PUSHM var             ; Сохраняем оба слова переменной var в стек

    ; Изменяем значение переменной var
    mov word ptr var, 0ABCDh   ; Устанавливаем новое значение для младшего слова
    mov word ptr var+2, 0EF01h ; Устанавливаем новое значение для старшего слова

    ; Извлекаем сохранённое значение из стека обратно в переменную var
    POPM var              ; Восстанавливаем оба слова переменной var из стека

    ; Вызов процедуры с использованием макроса CALLM
    CALLM my_procedure    ; Переход к процедуре my_procedure с сохранением адреса возврата

    ; Инициализация счётчика цикла
    mov CX, count         ; Загружаем значение из переменной count в CX

loop_start:
    ; Выводим символ 'A' на экран
    mov AH, 02h           ; Функция DOS для вывода символа
    mov DL, 'A'           ; Загружаем символ 'A' в DL
    int 21h               ; Вызов прерывания DOS

    ; Переходим на начало цикла loop_start, пока CX не станет равен 0
    LOOPM loop_start      ; Аналог команды LOOP

    ; Завершаем программу
    mov AH, 4Ch           ; Функция DOS для завершения программы
    int 21h               ; Вызов прерывания DOS

; Определение процедуры my_procedure
my_procedure:
    ; Выводим символ 'P' на экран
    mov AH, 02h           ; Функция DOS для вывода символа
    mov DL, 'P'           ; Загружаем символ 'P' в DL
    int 21h               ; Вызов прерывания DOS
    RETM 0                ; Возврат из процедуры, очищаем стек на 0 байт

code ends

end start                 ; Указываем начальную точку программы
