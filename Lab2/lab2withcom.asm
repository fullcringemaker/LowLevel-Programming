assume CS:code, DS:data

data segment
    arr dw 1, 3, 5, 2, 4, 6     ; Исходный массив слов
    arr_size dw 6               ; Количество элементов массива
data ends

code segment
start:
    ; Инициализация сегмента данных
    mov AX, data
    mov DS, AX

    ; Инициализируем SI, чтобы указывать на нулевой элемент массива
    mov SI, 0

    ; Загрузка нулевого элемента массива
    mov AX, word ptr arr[SI]    ; AX = arr[0] = 1

    ; Переход ко второму элементу
    add SI, 2                   ; SI = 2, указывает на arr[1]

    ; Загрузим размер массива в CX для цикла
    mov CX, word ptr arr_size    ; CX = размер массива (6 элементов)

    ; Начинаем обработку массива с 1-го индекса (второго элемента)
    dec CX                      ; Уменьшаем CX, так как первый элемент уже обработан

process_array:
    cmp CX, 0                   ; Проверяем, есть ли еще элементы для обработки
    je end_process              ; Если все элементы обработаны, переходим к завершению

    ; Загружаем текущий элемент в AX
    mov AX, word ptr arr[SI]    ; AX = текущий элемент массива

    ; Сравнение текущего элемента с предыдущим
    cmp AX, word ptr arr[SI-2]  ; Сравниваем текущий элемент с предыдущим
    jge skip_update             ; Если текущий элемент больше или равен, пропускаем обновление

    ; Если предыдущий элемент больше, обновляем текущий элемент
    mov AX, word ptr arr[SI-2]  ; AX = предыдущий элемент
    mov word ptr arr[SI], AX    ; Записываем значение в текущий элемент

skip_update:
    ; Переход к следующему элементу
    add SI, 2                   ; Увеличиваем SI на 2 (так как работаем со словами)
    dec CX                      ; Уменьшаем счетчик оставшихся элементов
    jmp process_array           ; Повторяем процесс для следующего элемента

end_process:
    ; Прерывание для выхода из программы
    mov AH, 4Ch
    int 21h

code ends
end start
